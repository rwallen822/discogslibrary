<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vinyl Collection</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Questrial&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%; height: 100%; overflow: hidden;
            background: #0a0a0a; font-family: 'Questrial', sans-serif;
        }
        .container {
            position: relative; width: 100vw; height: 100vh;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 50%, #0a0a0a 100%);
        }
        .slide {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            opacity: 0; transition: opacity 0.8s ease-in-out;
            display: flex; align-items: center; justify-content: center;
        }
        .slide.active { opacity: 1; z-index: 2; }
        .slide.previous { opacity: 0; z-index: 1; }
        
        .slide-content {
            display: flex; flex-direction: column; align-items: center;
            justify-content: space-between; height: 100%; width: 100%;
            padding: 2vh 0;
        }
        
        .artist {
            font-family: 'Questrial', sans-serif;
            font-size: clamp(0.9rem, 2.5vw, 2rem); font-weight: 400;
            color: #ffffff; letter-spacing: 0.02em;
            text-shadow: 0 4px 20px rgba(0,0,0,0.8);
            text-align: center; padding: 0 5vw;
            min-height: 1.5em;
        }
        
        .title {
            font-family: 'Questrial', sans-serif;
            font-size: clamp(0.8rem, 2vw, 1.5rem); font-weight: 400;
            color: rgba(255,255,255,0.7); letter-spacing: 0.2em;
            text-transform: uppercase; text-shadow: 0 2px 10px rgba(0,0,0,0.8);
            text-align: center; padding: 0 5vw;
            min-height: 1.5em;
        }
        
        .middle-section {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5vw;
            width: 100%;
            padding: 0 2vw;
        }
        
        .side-text {
            font-family: 'Questrial', sans-serif;
            font-size: clamp(0.7rem, 1.5vw, 1.1rem);
            color: rgba(255,255,255,0.6);
            text-shadow: 0 2px 10px rgba(0,0,0,0.8);
            width: 15vw;
            flex-shrink: 0;
        }
        
        .side-text.left {
            text-align: right;
        }
        
        .side-text.right {
            text-align: left;
            display: flex;
            flex-direction: column;
            max-height: 65vh;
        }
        
        .side-text-label {
            color: rgba(255,255,255,0.4);
            margin-bottom: 0.5em;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            font-size: 0.85em;
            flex-shrink: 0;
        }
        
        .side-text-content {
            margin-bottom: 1.5em;
        }
        
        .tracklist {
            font-size: clamp(0.6rem, 1.2vw, 0.95rem);
            line-height: 1.6;
            overflow: hidden;
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
        }
        
        .tracklist-inner {
            display: flex;
            flex-direction: column;
        }
        
        .track-item {
            margin-bottom: 0.3em;
            flex-shrink: 0;
        }
        
        .artwork-wrapper {
            position: relative;
            width: 65vh; height: 65vh;
            max-width: 60vw; max-height: 65vh;
            flex-shrink: 0;
        }
        .artwork-container {
            position: relative; 
            width: 100%; height: 100%;
            overflow: hidden;
            box-shadow: 0 30px 100px rgba(0,0,0,0.9), 0 15px 40px rgba(0,0,0,0.7);
            border-radius: 3px;
        }
        .artwork { 
            width: 100%; height: 100%; object-fit: cover; 
            will-change: transform, opacity, filter;
        }

        /* Typewriter cursor */
        .typewriter-cursor::after {
            content: '|';
            animation: blink 0.7s infinite;
            margin-left: 2px;
        }
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        /* Venetian Blinds */
        .blinds-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; overflow: hidden;
        }
        .blind-slat {
            flex: 1; background: #0a0a0a;
            transform-origin: top center;
            transition: transform 1.5s cubic-bezier(0.22, 1, 0.36, 1);
        }
        .blinds-container.open .blind-slat { transform: rotateX(90deg); }

        /* Checkerboard */
        .checker-grid {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: grid; grid-template-columns: repeat(8, 1fr); grid-template-rows: repeat(8, 1fr);
        }
        .checker-cell {
            background: #0a0a0a;
            transition: transform 1.2s cubic-bezier(0.22, 1, 0.36, 1), opacity 1.2s ease-out;
        }
        .checker-grid.reveal .checker-cell {
            transform: rotateY(180deg) scale(0); opacity: 0;
        }

        /* Iris */
        .iris-mask {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            clip-path: circle(0% at 50% 50%);
        }
        .iris-mask.animate {
            animation: iris-open 2s cubic-bezier(0.22, 1, 0.36, 1) forwards;
        }
        @keyframes iris-open {
            0% { clip-path: circle(0% at 50% 50%); }
            100% { clip-path: circle(75% at 50% 50%); }
        }

        /* Page Curl */
        .page-curl {
            transform-origin: left center;
            transform-style: preserve-3d;
        }
        .page-curl.animate {
            animation: page-turn 2s cubic-bezier(0.22, 1, 0.36, 1) forwards;
        }
        @keyframes page-turn {
            0% { transform: perspective(1500px) rotateY(-120deg); opacity: 0.5; }
            100% { transform: perspective(1500px) rotateY(0deg); opacity: 1; }
        }

        /* Cube Spin */
        .cube-spin {
            transform-style: preserve-3d;
        }
        .cube-spin.animate {
            animation: cube-rotate 2s cubic-bezier(0.22, 1, 0.36, 1) forwards;
        }
        @keyframes cube-rotate {
            0% { transform: perspective(1000px) rotateY(-180deg) rotateX(15deg) scale(0.8); opacity: 0; }
            100% { transform: perspective(1000px) rotateY(0deg) rotateX(0deg) scale(1); opacity: 1; }
        }

        /* Ripple */
        .ripple.animate {
            animation: ripple-wave 2.5s ease-out forwards;
        }
        @keyframes ripple-wave {
            0% { filter: url(#ripple-filter); opacity: 0; transform: scale(0.85); }
            40% { filter: url(#ripple-filter); opacity: 1; }
            100% { filter: none; opacity: 1; transform: scale(1); }
        }

        /* Pixelate */
        .pixelate.animate {
            animation: pixelate-in 2.5s steps(12) forwards;
        }
        @keyframes pixelate-in {
            0% { filter: url(#pixelate-large); opacity: 0; transform: scale(1.1); }
            20% { filter: url(#pixelate-large); opacity: 1; }
            50% { filter: url(#pixelate-medium); }
            80% { filter: url(#pixelate-small); }
            100% { filter: none; transform: scale(1); }
        }

        /* Stretch Zoom */
        .stretch-zoom.animate {
            animation: stretch-snap 1.8s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }
        @keyframes stretch-snap {
            0% { transform: scale(0.2, 0.05); opacity: 0; }
            30% { transform: scale(1.3, 0.7); opacity: 1; }
            50% { transform: scale(0.85, 1.15); }
            70% { transform: scale(1.05, 0.95); }
            85% { transform: scale(0.98, 1.02); }
            100% { transform: scale(1, 1); opacity: 1; }
        }

        /* Tunnel Zoom */
        .tunnel-zoom.animate {
            animation: tunnel-fly 2.5s cubic-bezier(0.22, 1, 0.36, 1) forwards;
        }
        @keyframes tunnel-fly {
            0% { transform: perspective(800px) translateZ(-2000px) rotateZ(360deg); opacity: 0; }
            30% { transform: perspective(800px) translateZ(-800px) rotateZ(180deg); opacity: 0.3; }
            60% { transform: perspective(800px) translateZ(-200px) rotateZ(45deg); opacity: 0.7; }
            100% { transform: perspective(800px) translateZ(0) rotateZ(0deg); opacity: 1; }
        }

        /* ========== VHS / RETRO BROADCAST EFFECTS ========== */

        /* Star Wipe - cheesy star-shaped mask reveal with hold and expand */
        .star-wipe-mask {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            clip-path: polygon(50% 50%, 50% 50%, 50% 50%, 50% 50%, 50% 50%,
                               50% 50%, 50% 50%, 50% 50%, 50% 50%, 50% 50%);
        }
        .star-wipe-mask.animate {
            animation: star-wipe 7s cubic-bezier(0.22, 1, 0.36, 1) forwards;
        }
        @keyframes star-wipe {
            /* Start: collapsed point */
            0% { clip-path: polygon(50% 50%, 50% 50%, 50% 50%, 50% 50%, 50% 50%,
                                    50% 50%, 50% 50%, 50% 50%, 50% 50%, 50% 50%); }
            /* 20%: Star shape formed */
            20% { clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%,
                                     50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%); }
            /* 60%: Hold at star shape (3 second hold) */
            60% { clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%,
                                     50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%); }
            /* 100%: Expand star beyond edges to reveal full image */
            100% { clip-path: polygon(50% -80%, 130% 20%, 150% 35%, 130% 80%, 120% 150%,
                                      50% 130%, -20% 150%, -30% 80%, -50% 35%, -30% 20%); }
        }

        /* Clock Wipe - pie-slice sweep reveal */
        .clock-wipe-mask {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            clip-path: polygon(50% 50%, 50% 0%, 50% 0%);
        }
        .clock-wipe-mask.animate {
            animation: clock-wipe 1.5s linear forwards;
        }
        @keyframes clock-wipe {
            0% { clip-path: polygon(50% 50%, 50% 0%, 50% 0%); }
            12.5% { clip-path: polygon(50% 50%, 50% 0%, 100% 0%); }
            25% { clip-path: polygon(50% 50%, 50% 0%, 100% 0%, 100% 50%); }
            37.5% { clip-path: polygon(50% 50%, 50% 0%, 100% 0%, 100% 100%); }
            50% { clip-path: polygon(50% 50%, 50% 0%, 100% 0%, 100% 100%, 50% 100%); }
            62.5% { clip-path: polygon(50% 50%, 50% 0%, 100% 0%, 100% 100%, 0% 100%); }
            75% { clip-path: polygon(50% 50%, 50% 0%, 100% 0%, 100% 100%, 0% 100%, 0% 50%); }
            87.5% { clip-path: polygon(50% 50%, 50% 0%, 100% 0%, 100% 100%, 0% 100%, 0% 0%); }
            100% { clip-path: polygon(50% 50%, 50% 0%, 100% 0%, 100% 100%, 0% 100%, 0% 0%, 50% 0%); }
        }

        /* Barn Door Wipe - two panels opening from center */
        .barn-door-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            overflow: hidden;
        }
        .barn-door-left, .barn-door-right {
            position: absolute; top: 0; width: 50%; height: 100%;
            background: #0a0a0a;
            transition: transform 1.2s cubic-bezier(0.22, 1, 0.36, 1);
        }
        .barn-door-left { left: 0; }
        .barn-door-right { right: 0; }
        .barn-door-container.open .barn-door-left { transform: translateX(-100%); }
        .barn-door-container.open .barn-door-right { transform: translateX(100%); }

        /* Flash Frame - hard cut with brief white flash */
        .flash-frame.animate {
            animation: flash-frame 0.3s steps(1) forwards;
        }
        .flash-frame::after {
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: white; opacity: 0; pointer-events: none;
        }
        .flash-frame.animate::after {
            animation: flash-overlay 0.3s steps(1) forwards;
        }
        @keyframes flash-frame {
            0% { opacity: 0; }
            33% { opacity: 0; }
            34% { opacity: 1; }
            100% { opacity: 1; }
        }
        @keyframes flash-overlay {
            0% { opacity: 0; }
            10% { opacity: 1; }
            40% { opacity: 1; }
            41% { opacity: 0; }
            100% { opacity: 0; }
        }

        /* Channel Switch Glitch - RGB split and jitter - AMPED UP */
        .channel-glitch.animate {
            animation: channel-glitch 0.6s steps(12) forwards;
        }
        @keyframes channel-glitch {
            0% { filter: none; transform: translateX(0) scaleY(1) skewX(0deg); opacity: 0; }
            8% { filter: drop-shadow(-12px 0 0 rgba(255,0,0,1)) drop-shadow(12px 0 0 rgba(0,255,255,1));
                  transform: translateX(-8px) scaleY(1.05) skewX(-3deg); opacity: 0.6; }
            16% { filter: drop-shadow(15px 0 0 rgba(255,0,0,1)) drop-shadow(-15px 0 0 rgba(0,255,255,1));
                  transform: translateX(10px) scaleY(0.95) skewX(4deg); opacity: 0.7; }
            24% { filter: drop-shadow(-10px 0 0 rgba(255,0,0,1)) drop-shadow(10px 0 0 rgba(0,255,255,1)) brightness(1.3);
                  transform: translateX(-6px) scaleY(1.03) skewX(-2deg); opacity: 0.85; }
            32% { filter: drop-shadow(8px 0 0 rgba(255,0,0,0.9)) drop-shadow(-8px 0 0 rgba(0,255,255,0.9));
                  transform: translateX(5px) scaleY(0.97) skewX(2deg); opacity: 0.9; }
            48% { filter: drop-shadow(-5px 0 0 rgba(255,0,0,0.7)) drop-shadow(5px 0 0 rgba(0,255,255,0.7));
                  transform: translateX(-3px) scaleY(1.01) skewX(-1deg); opacity: 0.95; }
            64% { filter: drop-shadow(3px 0 0 rgba(255,0,0,0.4)) drop-shadow(-3px 0 0 rgba(0,255,255,0.4));
                  transform: translateX(2px) skewX(0.5deg); opacity: 1; }
            100% { filter: none; transform: translateX(0) scaleY(1) skewX(0deg); opacity: 1; }
        }

        /* VHS Tracking Roll - horizontal distortion bar moving down - AMPED UP */
        .vhs-tracking-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            overflow: hidden;
        }
        .vhs-tracking-line {
            position: absolute; left: 0; width: 100%; height: 80px;
            background: linear-gradient(180deg,
                transparent 0%,
                rgba(255,255,255,0.15) 10%,
                rgba(255,255,255,0.4) 30%,
                rgba(255,255,255,0.8) 48%,
                rgba(0,0,0,0.3) 52%,
                rgba(255,255,255,0.4) 70%,
                rgba(255,255,255,0.15) 90%,
                transparent 100%);
            transform: translateY(-100%);
            mix-blend-mode: hard-light;
            filter: blur(1px);
        }
        .vhs-tracking-container.animate {
            animation: vhs-container-shake 1.5s ease-out forwards;
        }
        .vhs-tracking-container.animate .vhs-tracking-line {
            animation: vhs-tracking-roll 1.5s ease-out forwards;
        }
        @keyframes vhs-tracking-roll {
            0% { transform: translateY(-80px) scaleY(1); }
            50% { transform: translateY(50vh) scaleY(1.2); }
            100% { transform: translateY(calc(100vh + 80px)) scaleY(1); }
        }
        @keyframes vhs-container-shake {
            0%, 100% { transform: translateX(0); }
            10% { transform: translateX(-3px); }
            20% { transform: translateX(4px); }
            30% { transform: translateX(-2px); }
            40% { transform: translateX(3px); }
            50% { transform: translateX(-4px); }
            60% { transform: translateX(2px); }
            70% { transform: translateX(-3px); }
            80% { transform: translateX(1px); }
        }

        /* Scanline Intensify - scanlines pulse during transition - AMPED UP */
        .scanline-intensify {
            position: relative;
        }
        .scanline-intensify::before {
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: repeating-linear-gradient(
                0deg,
                transparent 0px,
                transparent 3px,
                rgba(0,0,0,0.7) 3px,
                rgba(0,0,0,0.7) 6px
            );
            opacity: 0; pointer-events: none; z-index: 10;
        }
        .scanline-intensify::after {
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(180deg,
                transparent 0%,
                rgba(255,255,255,0.1) 50%,
                transparent 100%);
            background-size: 100% 8px;
            opacity: 0; pointer-events: none; z-index: 11;
            animation: none;
        }
        .scanline-intensify.animate::before {
            animation: scanline-pulse 1.2s ease-out forwards;
        }
        .scanline-intensify.animate::after {
            animation: scanline-flicker 1.2s steps(4) forwards;
        }
        .scanline-intensify.animate {
            animation: scanline-reveal 1.2s ease-out forwards;
        }
        @keyframes scanline-pulse {
            0% { opacity: 0; }
            15% { opacity: 1; }
            30% { opacity: 0.5; }
            45% { opacity: 0.9; }
            60% { opacity: 0.4; }
            75% { opacity: 0.6; }
            100% { opacity: 0; }
        }
        @keyframes scanline-flicker {
            0% { opacity: 0; background-position: 0 0; }
            20% { opacity: 0.4; background-position: 0 2px; }
            40% { opacity: 0.2; background-position: 0 4px; }
            60% { opacity: 0.5; background-position: 0 1px; }
            80% { opacity: 0.1; background-position: 0 3px; }
            100% { opacity: 0; }
        }
        @keyframes scanline-reveal {
            0% { opacity: 0; filter: brightness(1.3); }
            20% { opacity: 0.8; filter: brightness(1.2); }
            40% { opacity: 1; filter: brightness(1); }
            100% { opacity: 1; filter: brightness(1); }
        }

        /* Chroma Bleed - color separation/smear effect - AMPED UP */
        .chroma-bleed.animate {
            animation: chroma-bleed 1s ease-out forwards;
        }
        @keyframes chroma-bleed {
            0% { filter: none; opacity: 0; transform: translateX(0) scale(1); }
            10% { filter: drop-shadow(-20px 0 0 rgba(255,0,0,1)) drop-shadow(20px 0 0 rgba(0,255,255,1))
                         drop-shadow(-10px 0 0 rgba(255,0,255,0.5)) blur(4px) saturate(1.5);
                  opacity: 0.6; transform: translateX(-5px) scale(1.02); }
            25% { filter: drop-shadow(-15px 0 0 rgba(255,0,0,0.9)) drop-shadow(15px 0 0 rgba(0,255,255,0.9))
                         drop-shadow(8px 0 0 rgba(255,255,0,0.4)) blur(3px) saturate(1.3);
                  opacity: 0.8; transform: translateX(4px) scale(1.01); }
            40% { filter: drop-shadow(-10px 0 0 rgba(255,0,0,0.7)) drop-shadow(10px 0 0 rgba(0,255,255,0.7)) blur(2px);
                  opacity: 0.9; transform: translateX(-2px) scale(1); }
            60% { filter: drop-shadow(-5px 0 0 rgba(255,0,0,0.4)) drop-shadow(5px 0 0 rgba(0,255,255,0.4)) blur(1px);
                  opacity: 1; transform: translateX(1px); }
            80% { filter: drop-shadow(-2px 0 0 rgba(255,0,0,0.2)) drop-shadow(2px 0 0 rgba(0,255,255,0.2));
                  opacity: 1; transform: translateX(0); }
            100% { filter: none; opacity: 1; transform: translateX(0) scale(1); }
        }

        /* Posterize Burst - brief posterized color look - AMPED UP */
        .posterize-burst.animate {
            animation: posterize-burst 0.8s steps(6) forwards;
        }
        @keyframes posterize-burst {
            0% { filter: contrast(100%) saturate(100%) hue-rotate(0deg); opacity: 0; transform: scale(1); }
            15% { filter: contrast(500%) saturate(400%) brightness(1.4) hue-rotate(20deg);
                  opacity: 0.7; transform: scale(1.03); }
            30% { filter: contrast(600%) saturate(300%) brightness(1.3) hue-rotate(-15deg);
                  opacity: 0.9; transform: scale(1.01); }
            45% { filter: contrast(400%) saturate(350%) brightness(1.2) hue-rotate(10deg);
                  opacity: 1; transform: scale(1.02); }
            60% { filter: contrast(300%) saturate(200%) brightness(1.1) hue-rotate(-5deg);
                  opacity: 1; transform: scale(1); }
            80% { filter: contrast(150%) saturate(130%) hue-rotate(0deg);
                  opacity: 1; }
            100% { filter: contrast(100%) saturate(100%) hue-rotate(0deg); opacity: 1; transform: scale(1); }
        }

        /* Static Burst - TV noise/static effect - AMPED UP */
        .static-burst {
            position: relative;
        }
        .static-burst::before {
            content: ''; position: absolute; top: -10%; left: -10%; width: 120%; height: 120%;
            background: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
            opacity: 0; mix-blend-mode: screen; pointer-events: none; z-index: 10;
        }
        .static-burst::after {
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: repeating-linear-gradient(
                0deg,
                transparent 0px,
                transparent 2px,
                rgba(255,255,255,0.03) 2px,
                rgba(255,255,255,0.03) 4px
            );
            opacity: 0; pointer-events: none; z-index: 11;
        }
        .static-burst.animate {
            animation: static-reveal 0.6s ease-out forwards;
        }
        .static-burst.animate::before {
            animation: static-noise 0.6s steps(8) forwards;
        }
        .static-burst.animate::after {
            animation: static-lines 0.6s steps(3) forwards;
        }
        @keyframes static-reveal {
            0% { opacity: 0; filter: brightness(2) contrast(0.5); }
            15% { opacity: 0.5; filter: brightness(1.8) contrast(0.7); }
            30% { opacity: 0.9; filter: brightness(1.3) contrast(0.9); }
            50% { opacity: 1; filter: brightness(1); }
            100% { opacity: 1; filter: brightness(1) contrast(1); }
        }
        @keyframes static-noise {
            0% { opacity: 1; transform: scale(2.5) translateX(5%); }
            12% { opacity: 1; transform: scale(3) translateX(-8%) translateY(3%); }
            25% { opacity: 0.9; transform: scale(2.2) translateX(10%) translateY(-5%); }
            37% { opacity: 0.8; transform: scale(2.8) translateX(-5%) translateY(2%); }
            50% { opacity: 0.6; transform: scale(1.8) translateX(3%); }
            62% { opacity: 0.4; transform: scale(1.5) translateX(-3%); }
            75% { opacity: 0.2; transform: scale(1.2); }
            100% { opacity: 0; transform: scale(1); }
        }
        @keyframes static-lines {
            0% { opacity: 0.8; }
            33% { opacity: 0.5; }
            66% { opacity: 0.2; }
            100% { opacity: 0; }
        }

        .loading {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #0a0a0a; display: flex; flex-direction: column;
            align-items: center; justify-content: center; z-index: 1000;
            transition: opacity 0.5s ease-out;
        }
        .loading.hidden { opacity: 0; pointer-events: none; }
        .loading-text {
            font-family: 'Questrial', sans-serif; font-size: 1.5rem;
            color: rgba(255,255,255,0.6); margin-bottom: 2rem;
        }
        .loading-progress { width: 200px; height: 2px; background: rgba(255,255,255,0.1); border-radius: 1px; overflow: hidden; }
        .loading-bar { height: 100%; background: rgba(255,255,255,0.6); width: 0%; transition: width 0.3s ease-out; }
        .placeholder {
            width: 100%; height: 100%;
            background: linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);
            display: flex; align-items: center; justify-content: center;
        }
        .placeholder-icon { width: 30%; height: 30%; opacity: 0.2; }
        .vignette {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 5;
            background: radial-gradient(ellipse at center, transparent 50%, rgba(0,0,0,0.5) 100%);
        }

        /* Welcome Screen */
        .welcome-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #0a0a0a; display: flex; flex-direction: column;
            align-items: center; justify-content: center; z-index: 2000;
            transition: opacity 0.5s ease-out;
        }
        .welcome-screen.hidden { opacity: 0; pointer-events: none; }
        .welcome-screen h1 {
            font-family: 'Questrial', sans-serif; font-size: clamp(2rem, 5vw, 4rem);
            color: #ffffff; margin-bottom: 0.5rem; letter-spacing: 0.1em;
        }
        .welcome-screen p {
            font-family: 'Questrial', sans-serif; font-size: 1.1rem;
            color: rgba(255,255,255,0.5); margin-bottom: 2rem;
        }
        .welcome-screen input {
            font-family: 'Questrial', sans-serif; font-size: 1.2rem;
            padding: 1rem 1.5rem; width: 300px; max-width: 80vw;
            background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2);
            border-radius: 4px; color: #ffffff; text-align: center;
            outline: none; transition: border-color 0.3s;
        }
        .welcome-screen input::placeholder { color: rgba(255,255,255,0.3); }
        .welcome-screen input:focus { border-color: rgba(255,255,255,0.5); }
        .welcome-screen button {
            font-family: 'Questrial', sans-serif; font-size: 1rem;
            padding: 0.8rem 2rem; margin-top: 1.5rem;
            background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3);
            border-radius: 4px; color: #ffffff; cursor: pointer;
            transition: background 0.3s, transform 0.2s; letter-spacing: 0.1em;
        }
        .welcome-screen button:hover { background: rgba(255,255,255,0.2); transform: scale(1.02); }
        .welcome-screen button:disabled { opacity: 0.5; cursor: not-allowed; }
        .welcome-error {
            color: #ff6b6b; font-size: 0.9rem; margin-top: 1rem;
            font-family: 'Questrial', sans-serif;
        }

        /* Settings Button */
        .settings-btn {
            position: fixed; top: 20px; right: 20px; z-index: 100;
            width: 50px; height: 50px; border-radius: 50%;
            background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2);
            color: #fff; cursor: pointer; font-size: 1.5rem;
            display: flex; align-items: center; justify-content: center;
            opacity: 0; pointer-events: none;
            transition: opacity 0.3s ease, background 0.2s ease;
        }
        .settings-btn.visible { opacity: 1; pointer-events: auto; }
        .settings-btn:hover { background: rgba(255,255,255,0.2); }

        /* Settings Panel */
        .settings-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); z-index: 3000;
            display: none; align-items: center; justify-content: center;
        }
        .settings-overlay.open { display: flex; }
        .settings-panel {
            background: #1a1a1a; border: 1px solid rgba(255,255,255,0.2);
            border-radius: 12px; padding: 2rem; width: 90%; max-width: 500px;
            max-height: 80vh; overflow-y: auto;
            font-family: 'Questrial', sans-serif; color: #fff;
        }
        .settings-panel h2 {
            margin: 0 0 1.5rem 0; font-size: 1.5rem; font-weight: 400;
            letter-spacing: 0.1em; text-align: center;
        }
        .settings-section {
            margin-bottom: 1.5rem; padding-bottom: 1.5rem;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .settings-section:last-child { border-bottom: none; margin-bottom: 0; }
        .settings-section h3 {
            font-size: 0.85rem; font-weight: 400; color: rgba(255,255,255,0.5);
            letter-spacing: 0.15em; text-transform: uppercase; margin: 0 0 1rem 0;
        }
        .setting-row {
            display: flex; align-items: center; justify-content: space-between;
            margin-bottom: 0.8rem; min-height: 40px;
        }
        .setting-row:last-child { margin-bottom: 0; }
        .setting-label { font-size: 1rem; color: rgba(255,255,255,0.8); }

        /* Toggle Switch */
        .toggle { position: relative; width: 50px; height: 28px; }
        .toggle input { display: none; }
        .toggle-slider {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255,255,255,0.2); border-radius: 28px;
            cursor: pointer; transition: background 0.3s;
        }
        .toggle-slider::before {
            content: ''; position: absolute; width: 22px; height: 22px;
            left: 3px; bottom: 3px; background: #fff; border-radius: 50%;
            transition: transform 0.3s;
        }
        .toggle input:checked + .toggle-slider { background: #4CAF50; }
        .toggle input:checked + .toggle-slider::before { transform: translateX(22px); }

        /* Range Slider */
        .range-container { display: flex; align-items: center; gap: 10px; }
        .range-value { font-size: 0.9rem; min-width: 35px; text-align: right; }
        input[type="range"] {
            width: 120px; height: 6px; -webkit-appearance: none;
            background: rgba(255,255,255,0.2); border-radius: 3px; cursor: pointer;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 18px; height: 18px;
            background: #fff; border-radius: 50%; cursor: pointer;
        }

        /* Effect Checkboxes */
        .effects-grid {
            display: grid; grid-template-columns: 1fr 1fr;
            gap: 0.5rem 1rem;
        }
        .effect-checkbox {
            display: flex; align-items: center; gap: 8px;
            font-size: 0.9rem; color: rgba(255,255,255,0.8); cursor: pointer;
        }
        .effect-checkbox input {
            width: 18px; height: 18px; accent-color: #4CAF50; cursor: pointer;
        }

        /* Close Button */
        .settings-close {
            display: block; width: 100%; margin-top: 1.5rem; padding: 0.8rem;
            background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px; color: #fff; font-family: 'Questrial', sans-serif;
            font-size: 1rem; cursor: pointer; transition: background 0.2s;
        }
        .settings-close:hover { background: rgba(255,255,255,0.2); }

        /* Box Set Manager */
        .boxset-manager-btn {
            width: 100%; padding: 0.6rem 1rem;
            background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2);
            border-radius: 4px; color: #fff; font-family: 'Questrial', sans-serif;
            font-size: 0.9rem; cursor: pointer; transition: background 0.2s;
        }
        .boxset-manager-btn:hover { background: rgba(255,255,255,0.2); }

        .boxset-modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 4000;
            display: none; align-items: center; justify-content: center;
        }
        .boxset-modal.open { display: flex; }
        .boxset-panel {
            background: #1a1a1a; border: 1px solid rgba(255,255,255,0.2);
            border-radius: 12px; padding: 2rem; width: 90%; max-width: 600px;
            max-height: 80vh; overflow-y: auto;
            font-family: 'Questrial', sans-serif; color: #fff;
        }
        .boxset-panel h2 { margin: 0 0 1rem 0; font-size: 1.3rem; font-weight: 400; }
        .boxset-list { margin-bottom: 1.5rem; }
        .boxset-item {
            display: flex; align-items: center; gap: 1rem;
            padding: 0.8rem; margin-bottom: 0.5rem;
            background: rgba(255,255,255,0.05); border-radius: 6px;
        }
        .boxset-item-info { flex: 1; }
        .boxset-item-title { font-size: 1rem; margin-bottom: 0.2rem; }
        .boxset-item-artist { font-size: 0.85rem; color: rgba(255,255,255,0.5); }
        .boxset-item-count { font-size: 0.8rem; color: rgba(255,255,255,0.4); }
        .boxset-empty {
            text-align: center; padding: 2rem;
            color: rgba(255,255,255,0.4); font-style: italic;
        }
        .boxset-loading {
            text-align: center; padding: 2rem;
            color: rgba(255,255,255,0.6);
        }
        .boxset-close {
            display: block; width: 100%; padding: 0.8rem;
            background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px; color: #fff; font-family: 'Questrial', sans-serif;
            font-size: 1rem; cursor: pointer; transition: background 0.2s;
        }
        .boxset-close:hover { background: rgba(255,255,255,0.2); }
    </style>
</head>
<body>
    <!-- SVG Filters -->
    <svg style="position: absolute; width: 0; height: 0;">
        <defs>
            <filter id="ripple-filter">
                <feTurbulence type="fractalNoise" baseFrequency="0.015" numOctaves="3" result="noise"/>
                <feDisplacementMap in="SourceGraphic" in2="noise" scale="40" xChannelSelector="R" yChannelSelector="G"/>
            </filter>
            <filter id="pixelate-large">
                <feFlood x="4" y="4" height="2" width="2"/>
                <feComposite width="20" height="20"/>
                <feTile result="a"/>
                <feComposite in="SourceGraphic" in2="a" operator="in"/>
                <feMorphology operator="dilate" radius="10"/>
            </filter>
            <filter id="pixelate-medium">
                <feFlood x="2" y="2" height="1" width="1"/>
                <feComposite width="10" height="10"/>
                <feTile result="a"/>
                <feComposite in="SourceGraphic" in2="a" operator="in"/>
                <feMorphology operator="dilate" radius="5"/>
            </filter>
            <filter id="pixelate-small">
                <feFlood x="1" y="1" height="1" width="1"/>
                <feComposite width="4" height="4"/>
                <feTile result="a"/>
                <feComposite in="SourceGraphic" in2="a" operator="in"/>
                <feMorphology operator="dilate" radius="2"/>
            </filter>
        </defs>
    </svg>

    <div class="welcome-screen" id="welcomeScreen">
        <h1>VINYL DISPLAY</h1>
        <p>Enter your Discogs username to view your collection</p>
        <input type="text" id="usernameInput" placeholder="Discogs username" autocomplete="off">
        <button id="startButton">View Collection</button>
        <div class="welcome-error" id="welcomeError"></div>
    </div>

    <div class="loading" id="loading">
        <div class="loading-text">Loading your collection...</div>
        <div class="loading-progress"><div class="loading-bar" id="loadingBar"></div></div>
    </div>
    <div class="container" id="container"></div>
    <div class="vignette"></div>

    <!-- Settings Button -->
    <button class="settings-btn" id="settingsBtn" title="Settings">âš™</button>

    <!-- Settings Panel -->
    <div class="settings-overlay" id="settingsOverlay">
        <div class="settings-panel">
            <h2>Settings</h2>

            <div class="settings-section">
                <h3>Playback</h3>
                <div class="setting-row">
                    <span class="setting-label">Duration per album</span>
                    <div class="range-container">
                        <input type="range" id="settingDuration" min="5" max="30" value="15">
                        <span class="range-value" id="durationValue">15s</span>
                    </div>
                </div>
                <div class="setting-row">
                    <span class="setting-label">Shuffle</span>
                    <label class="toggle">
                        <input type="checkbox" id="settingShuffle" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
            </div>

            <div class="settings-section">
                <h3>Text Overlays</h3>
                <div class="setting-row">
                    <span class="setting-label">Show artist name</span>
                    <label class="toggle">
                        <input type="checkbox" id="settingShowArtist" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="setting-row">
                    <span class="setting-label">Show album title</span>
                    <label class="toggle">
                        <input type="checkbox" id="settingShowTitle" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="setting-row">
                    <span class="setting-label">Show genre/style</span>
                    <label class="toggle">
                        <input type="checkbox" id="settingShowGenre" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="setting-row">
                    <span class="setting-label">Show tracklist</span>
                    <label class="toggle">
                        <input type="checkbox" id="settingShowTracklist" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
            </div>

            <div class="settings-section">
                <h3>Effects</h3>
                <div class="setting-row">
                    <span class="setting-label">Enable transitions</span>
                    <label class="toggle">
                        <input type="checkbox" id="settingTransitions" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="effects-grid" id="effectsGrid">
                    <label class="effect-checkbox"><input type="checkbox" data-effect="venetian-blinds" checked> Venetian Blinds</label>
                    <label class="effect-checkbox"><input type="checkbox" data-effect="checkerboard" checked> Checkerboard</label>
                    <label class="effect-checkbox"><input type="checkbox" data-effect="iris" checked> Iris</label>
                    <label class="effect-checkbox"><input type="checkbox" data-effect="page-curl" checked> Page Curl</label>
                    <label class="effect-checkbox"><input type="checkbox" data-effect="cube-spin" checked> Cube Spin</label>
                    <label class="effect-checkbox"><input type="checkbox" data-effect="ripple" checked> Ripple</label>
                    <label class="effect-checkbox"><input type="checkbox" data-effect="pixelate" checked> Pixelate</label>
                    <label class="effect-checkbox"><input type="checkbox" data-effect="stretch-zoom" checked> Stretch Zoom</label>
                    <label class="effect-checkbox"><input type="checkbox" data-effect="tunnel-zoom" checked> Tunnel Zoom</label>
                    <!-- VHS / Retro Broadcast Effects -->
                    <label class="effect-checkbox"><input type="checkbox" data-effect="star-wipe" checked> Star Wipe</label>
                    <label class="effect-checkbox"><input type="checkbox" data-effect="clock-wipe" checked> Clock Wipe</label>
                    <label class="effect-checkbox"><input type="checkbox" data-effect="barn-door" checked> Barn Door</label>
                    <label class="effect-checkbox"><input type="checkbox" data-effect="flash-frame" checked> Flash Frame</label>
                    <label class="effect-checkbox"><input type="checkbox" data-effect="channel-glitch" checked> Channel Glitch</label>
                    <label class="effect-checkbox"><input type="checkbox" data-effect="vhs-tracking" checked> VHS Tracking</label>
                    <label class="effect-checkbox"><input type="checkbox" data-effect="scanline-intensify" checked> Scanline Pulse</label>
                    <label class="effect-checkbox"><input type="checkbox" data-effect="chroma-bleed" checked> Chroma Bleed</label>
                    <label class="effect-checkbox"><input type="checkbox" data-effect="posterize-burst" checked> Posterize Burst</label>
                    <label class="effect-checkbox"><input type="checkbox" data-effect="static-burst" checked> Static Burst</label>
                </div>
            </div>

            <div class="settings-section">
                <h3>Box Sets</h3>
                <div class="setting-row">
                    <span class="setting-label">Expand box sets</span>
                    <label class="toggle">
                        <input type="checkbox" id="settingExpandBoxSets" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="setting-row">
                    <button class="boxset-manager-btn" id="boxSetManagerBtn">Manage Box Sets</button>
                </div>
            </div>

            <button class="settings-close" id="settingsClose">Close</button>
        </div>
    </div>

    <!-- Box Set Manager Modal -->
    <div class="boxset-modal" id="boxSetModal">
        <div class="boxset-panel">
            <h2>Box Set Manager</h2>
            <div class="boxset-list" id="boxSetList">
                <div class="boxset-empty">No box sets detected yet. Load your collection first.</div>
            </div>
            <button class="boxset-close" id="boxSetClose">Close</button>
        </div>
    </div>

    <script>
        const DISCOGS_TOKEN = 'QdGTPELWMUMKooWoGWwMkSlePUTLbSbGuvkxUWdm';
        const SLIDE_DURATION = 15000;
        const CROSSFADE_DURATION = 800;

        const ALL_EFFECTS = [
            'venetian-blinds',
            'checkerboard',
            'iris',
            'page-curl',
            'cube-spin',
            'ripple',
            'pixelate',
            'stretch-zoom',
            'tunnel-zoom',
            // VHS / Retro Broadcast Effects
            'star-wipe',
            'clock-wipe',
            'barn-door',
            'flash-frame',
            'channel-glitch',
            'vhs-tracking',
            'scanline-intensify',
            'chroma-bleed',
            'posterize-burst',
            'static-burst'
        ];

        // Settings with defaults
        const defaultSettings = {
            duration: 15,
            shuffle: true,
            showArtist: true,
            showTitle: true,
            showGenre: true,
            showTracklist: true,
            enableTransitions: true,
            enabledEffects: [...ALL_EFFECTS],
            expandBoxSets: true
        };

        let settings = { ...defaultSettings };

        function loadSettings() {
            try {
                const saved = localStorage.getItem('vinylDisplaySettings');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    settings = { ...defaultSettings, ...parsed };
                }
            } catch (e) {
                console.error('Error loading settings:', e);
            }
        }

        function saveSettings() {
            try {
                localStorage.setItem('vinylDisplaySettings', JSON.stringify(settings));
            } catch (e) {
                console.error('Error saving settings:', e);
            }
        }

        function getEnabledEffects() {
            return settings.enableTransitions && settings.enabledEffects.length > 0
                ? settings.enabledEffects
                : ['none'];
        }

        // Auto-hide settings button
        let inactivityTimer = null;
        let settingsPanelOpen = false;

        function showSettingsButton() {
            const btn = document.getElementById('settingsBtn');
            if (btn) btn.classList.add('visible');
            resetInactivityTimer();
        }

        function hideSettingsButton() {
            if (settingsPanelOpen) return;
            const btn = document.getElementById('settingsBtn');
            if (btn) btn.classList.remove('visible');
        }

        function resetInactivityTimer() {
            if (inactivityTimer) clearTimeout(inactivityTimer);
            if (!settingsPanelOpen) {
                inactivityTimer = setTimeout(hideSettingsButton, 3000);
            }
        }

        function setupInactivityListeners() {
            const events = ['mousemove', 'click', 'keypress', 'touchstart', 'touchmove'];
            events.forEach(event => {
                document.addEventListener(event, showSettingsButton, { passive: true });
            });
        }

        let effectsQueue = [];
        let shuffledData = [];
        let currentIndex = 0;
        let releaseCache = new Map();
        let currentSlide = null;
        let nextSlideReady = null;

        function shuffle(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        async function fetchUserCollection(username) {
            const allReleases = [];
            let page = 1;
            let totalPages = 1;

            do {
                const response = await fetch(
                    `https://api.discogs.com/users/${encodeURIComponent(username)}/collection/folders/0/releases?page=${page}&per_page=100&token=${DISCOGS_TOKEN}`
                );

                if (!response.ok) {
                    if (response.status === 404) {
                        throw new Error('User not found. Check the username.');
                    }
                    throw new Error('Failed to fetch collection. Is the collection public?');
                }

                const data = await response.json();
                totalPages = data.pagination.pages;

                for (const item of data.releases) {
                    const info = item.basic_information;
                    allReleases.push({
                        release_id: String(info.id),
                        Artist: info.artists.map(a => a.name).join(', '),
                        Title: info.title,
                        // Capture format info for box set pre-filtering
                        formats: info.formats || []
                    });
                }

                page++;
            } while (page <= totalPages);

            return allReleases;
        }

        function getNextEffect() {
            const enabledEffects = getEnabledEffects();
            if (enabledEffects[0] === 'none') return 'none';
            if (effectsQueue.length === 0 || !effectsQueue.every(e => enabledEffects.includes(e))) {
                effectsQueue = shuffle([...enabledEffects]);
            }
            return effectsQueue.pop();
        }

        async function fetchReleaseData(releaseId, virtualRecord = null) {
            // Handle virtual albums (from box set expansion)
            if (virtualRecord && virtualRecord.isVirtual) {
                return {
                    imageUrl: virtualRecord.virtualImageUrl,
                    genres: virtualRecord.virtualGenres || [],
                    styles: virtualRecord.virtualStyles || [],
                    tracklist: [],
                    tracklistTitles: virtualRecord.virtualTracks || [],
                    formats: [],
                    title: virtualRecord.Title,
                    artists: []
                };
            }

            // Check cache - but only return if it has actual data (not a failed fetch)
            if (releaseCache.has(releaseId)) {
                const cached = releaseCache.get(releaseId);
                // Only use cache if it has an imageUrl (successful fetch)
                if (cached.imageUrl || cached._verified) {
                    return cached;
                }
            }

            // Retry logic for rate limiting
            const maxRetries = 2;
            let lastError = null;

            for (let attempt = 0; attempt <= maxRetries; attempt++) {
                try {
                    // Add delay between retries (and small delay to avoid rate limits)
                    if (attempt > 0) {
                        console.log(`[API] Retry ${attempt}/${maxRetries} for release ${releaseId}`);
                        await new Promise(r => setTimeout(r, 1000 * attempt));
                    }

                    // No auth token = per-IP rate limit (25/min) instead of shared token limit
                    const response = await fetchWithTimeout(`https://api.discogs.com/releases/${releaseId}`, {
                        headers: {
                            'User-Agent': 'VinylDisplayApp/1.0'
                        }
                    });

                    // Handle rate limiting specifically
                    if (response.status === 429) {
                        const retryAfter = response.headers.get('Retry-After') || 60;
                        console.warn(`[API] Rate limited on release ${releaseId}. Retry after ${retryAfter}s`);
                        lastError = new Error(`Rate limited (429)`);
                        await new Promise(r => setTimeout(r, Math.min(parseInt(retryAfter) * 1000, 5000)));
                        continue;
                    }

                    if (!response.ok) {
                        lastError = new Error(`HTTP ${response.status}`);
                        console.warn(`[API] Failed to fetch release ${releaseId}: HTTP ${response.status}`);
                        continue;
                    }

                    const data = await response.json();
                    const releaseData = {
                        imageUrl: data.images && data.images[0] ? data.images[0].uri : null,
                        genres: data.genres || [],
                        styles: data.styles || [],
                        tracklist: data.tracklist || [],
                        tracklistTitles: data.tracklist ? data.tracklist.map(t => t.title || 'Untitled').filter(Boolean) : [],
                        formats: data.formats || [],
                        title: data.title || '',
                        artists: data.artists || [],
                        _verified: true  // Mark as successfully fetched
                    };

                    // Only cache successful fetches
                    releaseCache.set(releaseId, releaseData);
                    return releaseData;

                } catch (error) {
                    lastError = error;
                    console.warn(`[API] Error fetching release ${releaseId} (attempt ${attempt + 1}):`, error.message);
                }
            }

            // All retries failed - return fallback but DON'T cache it
            console.error(`[API] All retries failed for release ${releaseId}:`, lastError?.message);
            return { imageUrl: null, genres: [], styles: [], tracklist: [], tracklistTitles: [], formats: [], title: '', artists: [] };
        }

        // Box Set Expansion System
        let boxSetCache = {};
        let apiRequestQueue = [];
        let isProcessingQueue = false;
        const BOX_SET_PROCESS_TIMEOUT = 30000; // 30 seconds max for entire box set processing
        const SINGLE_REQUEST_TIMEOUT = 10000; // 10 seconds per request

        // Check if a record might be a box set based on collection format info
        function isPotentialBoxSet(record) {
            const formats = record.formats || [];
            for (const format of formats) {
                const name = (format.name || '').toLowerCase();
                const text = (format.text || '').toLowerCase();
                const qty = parseInt(format.qty) || 1;
                const descriptions = (format.descriptions || []).map(d => d.toLowerCase());

                // Check for explicit "Box Set" in format
                if (name.includes('box set') || text.includes('box set')) {
                    return true;
                }
                if (descriptions.some(d => d.includes('box set'))) {
                    return true;
                }
                // Check for multi-disc (qty >= 3 is more likely a box set)
                if (qty >= 3) {
                    return true;
                }
            }
            return false;
        }

        // Fetch with timeout
        async function fetchWithTimeout(url, options = {}, timeout = SINGLE_REQUEST_TIMEOUT) {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), timeout);

            try {
                const response = await fetch(url, {
                    ...options,
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                return response;
            } catch (error) {
                clearTimeout(timeoutId);
                if (error.name === 'AbortError') {
                    throw new Error('Request timeout');
                }
                throw error;
            }
        }

        function loadBoxSetCache() {
            try {
                const saved = localStorage.getItem('vinylBoxSetCache');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    // Invalidate entries older than 7 days
                    const sevenDaysAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
                    for (const [key, value] of Object.entries(parsed)) {
                        if (value.lastUpdated && value.lastUpdated > sevenDaysAgo) {
                            boxSetCache[key] = value;
                        }
                    }
                }
            } catch (e) {
                console.error('Error loading box set cache:', e);
            }
        }

        function saveBoxSetCache() {
            try {
                localStorage.setItem('vinylBoxSetCache', JSON.stringify(boxSetCache));
            } catch (e) {
                console.error('Error saving box set cache:', e);
            }
        }

        function detectBoxSet(releaseData) {
            // Check if any format contains "Box Set" or indicates multiple discs
            const formats = releaseData.formats || [];
            for (const format of formats) {
                const name = (format.name || '').toLowerCase();
                const descriptions = (format.descriptions || []).map(d => d.toLowerCase());
                const qty = parseInt(format.qty) || 1;

                // Check for "Box Set" in name or descriptions
                if (name.includes('box set') || descriptions.some(d => d.includes('box set'))) {
                    return { isBoxSet: true, discCount: qty, reason: 'format-boxset' };
                }

                // Check for compilation box sets
                if (descriptions.some(d => d.includes('compilation') || d.includes('anthology'))) {
                    if (qty > 1) {
                        return { isBoxSet: true, discCount: qty, reason: 'format-compilation' };
                    }
                }

                // Check for multi-disc releases (2+ discs of same format)
                if (qty >= 2 && (name === 'vinyl' || name === 'lp' || name === 'cd')) {
                    return { isBoxSet: true, discCount: qty, reason: 'multi-disc' };
                }
            }

            // Check tracklist for sub-album headers
            const tracklist = releaseData.tracklist || [];
            let headingCount = 0;
            for (const track of tracklist) {
                const type = (track.type_ || '').toLowerCase();
                const position = track.position || '';

                // Count heading-type tracks (disc separators)
                if (type === 'heading' || type === 'index') {
                    headingCount++;
                }

                // Look for disc indicators in position
                if (/^[A-Z]\d*$/.test(position) || /^\d+-/.test(position)) {
                    // Multi-disc notation detected
                }
            }

            if (headingCount >= 2) {
                return { isBoxSet: true, discCount: headingCount, reason: 'tracklist-headers' };
            }

            return { isBoxSet: false, discCount: 1, reason: null };
        }

        function parseBoxSetTracklist(releaseData) {
            const tracklist = releaseData.tracklist || [];
            const subAlbums = [];
            let currentAlbum = null;

            for (const track of tracklist) {
                const type = (track.type_ || '').toLowerCase();
                const title = track.title || '';
                const position = track.position || '';

                // Check for heading (disc/album separator)
                if (type === 'heading' || type === 'index') {
                    // Save previous album if exists
                    if (currentAlbum && currentAlbum.tracks.length > 0) {
                        subAlbums.push(currentAlbum);
                    }
                    // Start new album
                    currentAlbum = {
                        title: title.replace(/^(Disc|CD|LP|Side)\s*\d*:?\s*/i, '').trim() || title,
                        tracks: [],
                        discNumber: subAlbums.length + 1
                    };
                } else if (type === 'track' || type === '') {
                    // Regular track
                    if (!currentAlbum) {
                        // Create default first album
                        currentAlbum = {
                            title: 'Disc 1',
                            tracks: [],
                            discNumber: 1
                        };
                    }
                    currentAlbum.tracks.push(title);
                }
            }

            // Add last album
            if (currentAlbum && currentAlbum.tracks.length > 0) {
                subAlbums.push(currentAlbum);
            }

            // If we only got one album and the box set was detected by format,
            // try to split by disc position pattern
            if (subAlbums.length <= 1) {
                const byDisc = {};
                for (const track of tracklist) {
                    const position = track.position || '';
                    const title = track.title || '';

                    // Match patterns like "1-1", "A1", "CD1-1", etc.
                    let discNum = 1;
                    const discMatch = position.match(/^(?:CD|LP|Disc)?(\d+)[-\.]/i);
                    if (discMatch) {
                        discNum = parseInt(discMatch[1]);
                    } else if (/^[A-D]/.test(position)) {
                        // Vinyl side notation (A, B, C, D...)
                        const side = position.charAt(0).toUpperCase();
                        discNum = Math.ceil((side.charCodeAt(0) - 64) / 2); // A,B = 1, C,D = 2
                    }

                    if (!byDisc[discNum]) {
                        byDisc[discNum] = { title: `Disc ${discNum}`, tracks: [], discNumber: discNum };
                    }
                    byDisc[discNum].tracks.push(title);
                }

                const discAlbums = Object.values(byDisc).sort((a, b) => a.discNumber - b.discNumber);
                if (discAlbums.length > 1) {
                    return discAlbums;
                }
            }

            return subAlbums.length > 0 ? subAlbums : null;
        }

        // Throttled API request queue
        async function queueApiRequest(fn) {
            return new Promise((resolve, reject) => {
                apiRequestQueue.push({ fn, resolve, reject });
                processApiQueue();
            });
        }

        async function processApiQueue() {
            if (isProcessingQueue || apiRequestQueue.length === 0) return;
            isProcessingQueue = true;

            while (apiRequestQueue.length > 0) {
                const { fn, resolve, reject } = apiRequestQueue.shift();
                try {
                    const result = await fn();
                    resolve(result);
                } catch (error) {
                    reject(error);
                }
                // Wait 1 second between requests to respect rate limits
                if (apiRequestQueue.length > 0) {
                    await new Promise(r => setTimeout(r, 1000));
                }
            }

            isProcessingQueue = false;
        }

        async function searchAlbumCover(artist, albumTitle) {
            return queueApiRequest(async () => {
                try {
                    const query = encodeURIComponent(`${artist} ${albumTitle}`);
                    const response = await fetchWithTimeout(
                        `https://api.discogs.com/database/search?q=${query}&type=release&token=${DISCOGS_TOKEN}`,
                        { headers: { 'User-Agent': 'VinylDisplayApp/1.0' } },
                        SINGLE_REQUEST_TIMEOUT
                    );

                    if (!response.ok) return null;

                    const data = await response.json();
                    if (data.results && data.results.length > 0) {
                        // Find best match (prefer exact title match)
                        const exactMatch = data.results.find(r =>
                            r.title.toLowerCase().includes(albumTitle.toLowerCase())
                        );
                        const result = exactMatch || data.results[0];
                        return result.cover_image || result.thumb || null;
                    }
                    return null;
                } catch (error) {
                    console.log(`[BoxSet] Cover search failed for "${albumTitle}":`, error.message);
                    return null;
                }
            });
        }

        async function expandBoxSet(record, releaseData) {
            const detection = detectBoxSet(releaseData);
            if (!detection.isBoxSet) return null;

            const subAlbums = parseBoxSetTracklist(releaseData);
            if (!subAlbums || subAlbums.length <= 1) {
                // Can't parse into multiple albums, return null to keep original
                return null;
            }

            const virtualAlbums = [];
            const boxSetCover = releaseData.imageUrl;

            // Limit cover searches to first 5 sub-albums to avoid too many API calls
            const MAX_COVER_SEARCHES = 5;

            for (let i = 0; i < subAlbums.length; i++) {
                const subAlbum = subAlbums[i];
                let coverUrl = boxSetCover; // Default to box set cover

                // Only search for cover if we haven't hit the limit and title isn't generic
                const isGenericTitle = /^(Disc|CD|LP|Side)\s*\d+$/i.test(subAlbum.title);
                if (i < MAX_COVER_SEARCHES && !isGenericTitle) {
                    try {
                        const searchResult = await searchAlbumCover(record.Artist, subAlbum.title);
                        if (searchResult) {
                            coverUrl = searchResult;
                        }
                    } catch (error) {
                        console.log(`[BoxSet] Cover search failed for "${subAlbum.title}", using box set cover`);
                    }
                }

                virtualAlbums.push({
                    release_id: `${record.release_id}_disc${subAlbum.discNumber}`,
                    Artist: record.Artist,
                    Title: subAlbum.title,
                    isVirtual: true,
                    parentReleaseId: record.release_id,
                    parentTitle: record.Title,
                    virtualImageUrl: coverUrl,
                    virtualTracks: subAlbum.tracks,
                    virtualGenres: releaseData.genres,
                    virtualStyles: releaseData.styles
                });
            }

            return virtualAlbums;
        }

        async function processBoxSets(collectionData) {
            if (!settings.expandBoxSets) {
                console.log('[BoxSet] Box set expansion disabled');
                return collectionData;
            }

            console.log(`[BoxSet] Starting processing for ${collectionData.length} items`);
            loadBoxSetCache();

            const expandedCollection = [];
            const detectedBoxSets = [];
            const startTime = Date.now();
            let processedCount = 0;
            let skippedCount = 0;
            let errorCount = 0;

            // Pre-filter: only check items that might be box sets
            const potentialBoxSets = collectionData.filter(r => isPotentialBoxSet(r));
            const regularAlbums = collectionData.filter(r => !isPotentialBoxSet(r));

            console.log(`[BoxSet] Found ${potentialBoxSets.length} potential box sets, ${regularAlbums.length} regular albums`);

            // Add all regular albums directly
            expandedCollection.push(...regularAlbums);

            // Process potential box sets
            for (const record of potentialBoxSets) {
                // Check overall timeout
                if (Date.now() - startTime > BOX_SET_PROCESS_TIMEOUT) {
                    console.warn(`[BoxSet] Timeout reached after ${processedCount} items. Adding remaining as-is.`);
                    // Add remaining unprocessed items as-is
                    const remaining = potentialBoxSets.slice(potentialBoxSets.indexOf(record));
                    expandedCollection.push(...remaining);
                    skippedCount += remaining.length;
                    break;
                }

                processedCount++;
                const progress = Math.round((processedCount / potentialBoxSets.length) * 100);
                console.log(`[BoxSet] Processing ${processedCount}/${potentialBoxSets.length} (${progress}%): ${record.Title}`);

                try {
                    // Check cache first
                    if (boxSetCache[record.release_id]) {
                        const cached = boxSetCache[record.release_id];
                        if (cached.expanded && cached.virtualAlbums) {
                            expandedCollection.push(...cached.virtualAlbums);
                            detectedBoxSets.push({
                                record,
                                virtualAlbums: cached.virtualAlbums,
                                fromCache: true
                            });
                            console.log(`[BoxSet] Using cached expansion for ${record.Title}: ${cached.virtualAlbums.length} albums`);
                            continue;
                        } else if (cached.isBoxSet === false) {
                            expandedCollection.push(record);
                            continue;
                        }
                    }

                    // Fetch release data to check if box set
                    const releaseData = await fetchReleaseData(record.release_id);
                    const detection = detectBoxSet(releaseData);

                    if (detection.isBoxSet) {
                        console.log(`[BoxSet] Detected box set: ${record.Title} (reason: ${detection.reason})`);
                        const virtualAlbums = await expandBoxSet(record, releaseData);

                        if (virtualAlbums && virtualAlbums.length > 1) {
                            expandedCollection.push(...virtualAlbums);
                            boxSetCache[record.release_id] = {
                                isBoxSet: true,
                                expanded: true,
                                virtualAlbums,
                                lastUpdated: Date.now()
                            };
                            detectedBoxSets.push({
                                record,
                                virtualAlbums,
                                fromCache: false
                            });
                            console.log(`[BoxSet] Expanded ${record.Title} to ${virtualAlbums.length} albums`);
                        } else {
                            // Couldn't expand, keep original
                            expandedCollection.push(record);
                            boxSetCache[record.release_id] = {
                                isBoxSet: true,
                                expanded: false,
                                lastUpdated: Date.now()
                            };
                            console.log(`[BoxSet] Could not expand ${record.Title}, keeping original`);
                        }
                    } else {
                        expandedCollection.push(record);
                        boxSetCache[record.release_id] = {
                            isBoxSet: false,
                            lastUpdated: Date.now()
                        };
                    }
                } catch (error) {
                    errorCount++;
                    console.error(`[BoxSet] Error processing ${record.Title}:`, error.message);
                    // On error, just add the original record
                    expandedCollection.push(record);
                }
            }

            saveBoxSetCache();
            // Store detected box sets for manager UI
            window.detectedBoxSets = detectedBoxSets;

            const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
            console.log(`[BoxSet] Completed in ${elapsed}s. Processed: ${processedCount}, Skipped: ${skippedCount}, Errors: ${errorCount}`);
            console.log(`[BoxSet] Final collection: ${expandedCollection.length} items (${detectedBoxSets.length} box sets expanded)`);

            return expandedCollection;
        }

        function updateBoxSetManagerUI() {
            const listEl = document.getElementById('boxSetList');
            if (!listEl) return;

            const boxSets = window.detectedBoxSets || [];

            if (boxSets.length === 0) {
                listEl.innerHTML = '<div class="boxset-empty">No box sets detected in your collection.</div>';
                return;
            }

            let html = '';
            for (const bs of boxSets) {
                const albumCount = bs.virtualAlbums ? bs.virtualAlbums.length : 0;
                html += `
                    <div class="boxset-item">
                        <div class="boxset-item-info">
                            <div class="boxset-item-title">${escapeHtml(bs.record.Title)}</div>
                            <div class="boxset-item-artist">${escapeHtml(bs.record.Artist)}</div>
                            <div class="boxset-item-count">Expanded to ${albumCount} albums</div>
                        </div>
                    </div>
                `;
            }
            listEl.innerHTML = html;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function preloadImage(url) {
            return new Promise((resolve) => {
                if (!url) { resolve(null); return; }
                const img = new Image();
                img.onload = () => resolve(url);
                img.onerror = () => resolve(null);
                img.src = url;
            });
        }

        function typeWriter(element, text, speed, callback) {
            if (!element) {
                if (callback) callback();
                return;
            }
            let i = 0;
            element.textContent = '';
            element.classList.add('typewriter-cursor');
            
            function type() {
                if (i < text.length) {
                    element.textContent += text.charAt(i);
                    i++;
                    setTimeout(type, speed);
                } else {
                    element.classList.remove('typewriter-cursor');
                    if (callback) callback();
                }
            }
            type();
        }

        function showTracklist(element, tracks, callback) {
            if (!element) {
                if (callback) callback();
                return;
            }
            const inner = element.querySelector('.tracklist-inner') || element;
            inner.innerHTML = '';
            let trackIndex = 0;
            
            // Calculate delay per track to fit in ~2 seconds total
            const delayPerTrack = Math.max(100, 2000 / Math.max(tracks.length, 1));
            
            function revealNextTrack() {
                if (trackIndex < tracks.length) {
                    const trackDiv = document.createElement('div');
                    trackDiv.className = 'track-item';
                    trackDiv.textContent = tracks[trackIndex];
                    trackDiv.style.opacity = '0';
                    trackDiv.style.transition = 'opacity 0.3s ease-out';
                    inner.appendChild(trackDiv);
                    
                    // Trigger fade in
                    setTimeout(() => { trackDiv.style.opacity = '1'; }, 20);
                    
                    trackIndex++;
                    setTimeout(revealNextTrack, delayPerTrack);
                } else {
                    if (callback) callback();
                }
            }
            revealNextTrack();
        }

        function startTypewriterSequence(slide, record, releaseData) {
            const artistEl = slide.querySelector('.artist');
            const titleEl = slide.querySelector('.title');
            const genreEl = slide.querySelector('.genre-text');
            const styleEl = slide.querySelector('.style-text');
            const tracklistEl = slide.querySelector('.tracklist-text');

            const artistText = record.Artist;
            const titleText = record.Title;
            const genreText = releaseData.genres.join(', ') || 'Unknown';
            const styleText = releaseData.styles.join(', ') || 'Unknown';
            const tracks = releaseData.tracklistTitles || [];

            // Calculate speeds to fit within 10 seconds total
            // Artist: 0-2s, Title: 2-4s, Tracklist: 4s (instant), Genre: 4-6s, Style: 6-8s
            const artistSpeed = Math.max(20, 2000 / Math.max(artistText.length, 1));
            const titleSpeed = Math.max(20, 2000 / Math.max(titleText.length, 1));
            const genreSpeed = Math.max(20, 2000 / Math.max(genreText.length, 1));
            const styleSpeed = Math.max(20, 2000 / Math.max(styleText.length, 1));

            // Start artist immediately
            typeWriter(artistEl, artistText, artistSpeed, () => {
                // Start title after artist
                setTimeout(() => {
                    typeWriter(titleEl, titleText, titleSpeed, () => {
                        // Show tracklist with slow reveal after title
                        setTimeout(() => {
                            showTracklist(tracklistEl, tracks, () => {
                                // Start genre after tracklist finishes
                                setTimeout(() => {
                                    typeWriter(genreEl, genreText, genreSpeed, () => {
                                        // Start style after genre
                                        setTimeout(() => {
                                            typeWriter(styleEl, styleText, styleSpeed);
                                        }, 150);
                                    });
                                }, 200);
                            });
                        }, 150);
                    });
                }, 150);
            });
        }

        function createSlide(record, releaseData, effect) {
            const slide = document.createElement('div');
            slide.className = 'slide';
            slide.dataset.effect = effect;
            
            const slideContent = document.createElement('div');
            slideContent.className = 'slide-content';
            
            // Artist (top)
            const artist = document.createElement('div');
            artist.className = 'artist';
            if (!settings.showArtist) artist.style.visibility = 'hidden';
            
            // Middle section with genre/style (left), artwork (center), tracklist (right)
            const middleSection = document.createElement('div');
            middleSection.className = 'middle-section';
            
            // Genre and Style (left side)
            const leftContainer = document.createElement('div');
            leftContainer.className = 'side-text left';
            if (!settings.showGenre) leftContainer.style.visibility = 'hidden';
            
            const genreSection = document.createElement('div');
            genreSection.className = 'side-text-content';
            const genreLabel = document.createElement('div');
            genreLabel.className = 'side-text-label';
            genreLabel.textContent = 'Genre';
            const genreText = document.createElement('div');
            genreText.className = 'genre-text';
            genreSection.appendChild(genreLabel);
            genreSection.appendChild(genreText);
            
            const styleSection = document.createElement('div');
            styleSection.className = 'side-text-content';
            const styleLabel = document.createElement('div');
            styleLabel.className = 'side-text-label';
            styleLabel.textContent = 'Style';
            const styleText = document.createElement('div');
            styleText.className = 'style-text';
            styleSection.appendChild(styleLabel);
            styleSection.appendChild(styleText);
            
            leftContainer.appendChild(genreSection);
            leftContainer.appendChild(styleSection);
            
            // Artwork (center)
            const artworkWrapper = document.createElement('div');
            artworkWrapper.className = 'artwork-wrapper';
            
            const artworkContainer = document.createElement('div');
            artworkContainer.className = 'artwork-container';
            
            // Simple class-based effects (applied directly to container)
            const simpleEffects = [
                'ripple', 'pixelate', 'stretch-zoom', 'tunnel-zoom', 'page-curl', 'cube-spin',
                'channel-glitch', 'chroma-bleed', 'posterize-burst', 'scanline-intensify',
                'flash-frame', 'static-burst'
            ];
            if (simpleEffects.includes(effect)) {
                artworkContainer.classList.add(effect);
            }

            if (releaseData.imageUrl) {
                const img = document.createElement('img');
                img.className = 'artwork';
                img.src = releaseData.imageUrl;
                img.alt = `${record.Artist} - ${record.Title}`;

                if (effect === 'venetian-blinds') {
                    img.style.position = 'absolute';
                    img.style.top = '0';
                    img.style.left = '0';
                    artworkContainer.appendChild(img);
                    const blinds = document.createElement('div');
                    blinds.className = 'blinds-container';
                    for (let i = 0; i < 12; i++) {
                        const slat = document.createElement('div');
                        slat.className = 'blind-slat';
                        slat.style.transitionDelay = `${i * 0.1}s`;
                        blinds.appendChild(slat);
                    }
                    artworkContainer.appendChild(blinds);
                }
                else if (effect === 'checkerboard') {
                    img.style.position = 'absolute';
                    img.style.top = '0';
                    img.style.left = '0';
                    artworkContainer.appendChild(img);
                    const grid = document.createElement('div');
                    grid.className = 'checker-grid';
                    for (let i = 0; i < 64; i++) {
                        const cell = document.createElement('div');
                        cell.className = 'checker-cell';
                        cell.style.transitionDelay = `${Math.random() * 1.5}s`;
                        grid.appendChild(cell);
                    }
                    artworkContainer.appendChild(grid);
                }
                else if (effect === 'iris') {
                    const mask = document.createElement('div');
                    mask.className = 'iris-mask';
                    mask.appendChild(img);
                    artworkContainer.appendChild(mask);
                }
                else if (effect === 'star-wipe') {
                    const mask = document.createElement('div');
                    mask.className = 'star-wipe-mask';
                    mask.appendChild(img);
                    artworkContainer.appendChild(mask);
                }
                else if (effect === 'clock-wipe') {
                    const mask = document.createElement('div');
                    mask.className = 'clock-wipe-mask';
                    mask.appendChild(img);
                    artworkContainer.appendChild(mask);
                }
                else if (effect === 'barn-door') {
                    img.style.position = 'absolute';
                    img.style.top = '0';
                    img.style.left = '0';
                    artworkContainer.appendChild(img);
                    const barnDoor = document.createElement('div');
                    barnDoor.className = 'barn-door-container';
                    const leftDoor = document.createElement('div');
                    leftDoor.className = 'barn-door-left';
                    const rightDoor = document.createElement('div');
                    rightDoor.className = 'barn-door-right';
                    barnDoor.appendChild(leftDoor);
                    barnDoor.appendChild(rightDoor);
                    artworkContainer.appendChild(barnDoor);
                }
                else if (effect === 'vhs-tracking') {
                    img.style.position = 'absolute';
                    img.style.top = '0';
                    img.style.left = '0';
                    artworkContainer.appendChild(img);
                    const tracking = document.createElement('div');
                    tracking.className = 'vhs-tracking-container';
                    const line = document.createElement('div');
                    line.className = 'vhs-tracking-line';
                    tracking.appendChild(line);
                    artworkContainer.appendChild(tracking);
                }
                else {
                    artworkContainer.appendChild(img);
                }
            } else {
                const placeholder = document.createElement('div');
                placeholder.className = 'placeholder';
                placeholder.innerHTML = `<svg class="placeholder-icon" viewBox="0 0 100 100" fill="none">
                    <circle cx="50" cy="50" r="45" stroke="white" stroke-width="2"/>
                    <circle cx="50" cy="50" r="20" stroke="white" stroke-width="2"/>
                    <circle cx="50" cy="50" r="5" fill="white"/></svg>`;
                artworkContainer.appendChild(placeholder);
            }

            artworkWrapper.appendChild(artworkContainer);
            
            // Tracklist (right side)
            const tracklistContainer = document.createElement('div');
            tracklistContainer.className = 'side-text right';
            if (!settings.showTracklist) tracklistContainer.style.visibility = 'hidden';
            const tracklistLabel = document.createElement('div');
            tracklistLabel.className = 'side-text-label';
            tracklistLabel.textContent = 'Tracklist';
            const tracklistText = document.createElement('div');
            tracklistText.className = 'tracklist-text tracklist';
            const tracklistInner = document.createElement('div');
            tracklistInner.className = 'tracklist-inner';
            tracklistText.appendChild(tracklistInner);
            tracklistContainer.appendChild(tracklistLabel);
            tracklistContainer.appendChild(tracklistText);
            
            middleSection.appendChild(leftContainer);
            middleSection.appendChild(artworkWrapper);
            middleSection.appendChild(tracklistContainer);
            
            // Title (bottom)
            const title = document.createElement('div');
            title.className = 'title';
            if (!settings.showTitle) title.style.visibility = 'hidden';
            
            slideContent.appendChild(artist);
            slideContent.appendChild(middleSection);
            slideContent.appendChild(title);
            slide.appendChild(slideContent);
            
            // Store release data for typewriter
            slide.recordData = record;
            slide.releaseData = releaseData;
            
            return slide;
        }

        function triggerEffect(slide) {
            const effect = slide.dataset.effect;

            setTimeout(() => {
                if (effect === 'venetian-blinds') {
                    const blinds = slide.querySelector('.blinds-container');
                    if (blinds) blinds.classList.add('open');
                }
                else if (effect === 'checkerboard') {
                    const grid = slide.querySelector('.checker-grid');
                    if (grid) grid.classList.add('reveal');
                }
                else if (effect === 'iris') {
                    const mask = slide.querySelector('.iris-mask');
                    if (mask) mask.classList.add('animate');
                }
                else if (effect === 'star-wipe') {
                    const mask = slide.querySelector('.star-wipe-mask');
                    if (mask) mask.classList.add('animate');
                }
                else if (effect === 'clock-wipe') {
                    const mask = slide.querySelector('.clock-wipe-mask');
                    if (mask) mask.classList.add('animate');
                }
                else if (effect === 'barn-door') {
                    const barnDoor = slide.querySelector('.barn-door-container');
                    if (barnDoor) barnDoor.classList.add('open');
                }
                else if (effect === 'vhs-tracking') {
                    const tracking = slide.querySelector('.vhs-tracking-container');
                    if (tracking) tracking.classList.add('animate');
                }
                // All other effects (including new VHS effects) apply .animate to container
                else if ([
                    'page-curl', 'cube-spin', 'ripple', 'pixelate', 'stretch-zoom', 'tunnel-zoom',
                    'channel-glitch', 'chroma-bleed', 'posterize-burst', 'scanline-intensify',
                    'flash-frame', 'static-burst'
                ].includes(effect)) {
                    const container = slide.querySelector('.artwork-container');
                    if (container) container.classList.add('animate');
                }
            }, 100);

            // Start typewriter sequence
            startTypewriterSequence(slide, slide.recordData, slide.releaseData);
        }

        async function prepareNextSlide() {
            const record = shuffledData[currentIndex];
            const releaseData = await fetchReleaseData(record.release_id, record);
            await preloadImage(releaseData.imageUrl);
            return createSlide(record, releaseData, getNextEffect());
        }

        async function showNextSlide() {
            const container = document.getElementById('container');
            if (!container) {
                console.error('Container element not found');
                return;
            }
            let newSlide;
            if (nextSlideReady) {
                newSlide = nextSlideReady;
                nextSlideReady = null;
            } else {
                newSlide = await prepareNextSlide();
            }
            container.appendChild(newSlide);
            newSlide.offsetHeight;

            if (currentSlide) {
                currentSlide.classList.remove('active');
                currentSlide.classList.add('previous');
            }
            newSlide.classList.add('active');
            triggerEffect(newSlide);

            if (currentSlide) {
                const oldSlide = currentSlide;
                setTimeout(() => oldSlide.remove(), CROSSFADE_DURATION + 500);
            }
            currentSlide = newSlide;
            currentIndex = (currentIndex + 1) % shuffledData.length;
            setTimeout(async () => { nextSlideReady = await prepareNextSlide(); }, 2000);
        }

        async function startSlideshow(collectionData) {
            const loadingBar = document.getElementById('loadingBar');
            const loading = document.getElementById('loading');

            if (!loadingBar || !loading) {
                console.error('Required loading elements not found');
                return;
            }

            try {
                loadingBar.style.width = '30%';
                shuffledData = shuffle(collectionData);
                loadingBar.style.width = '50%';

                if (shuffledData.length === 0) throw new Error('No records found');
                console.log(`Loaded ${shuffledData.length} records`);

                const firstRecord = shuffledData[0];
                const firstReleaseData = await fetchReleaseData(firstRecord.release_id, firstRecord);
                await preloadImage(firstReleaseData.imageUrl);
                loadingBar.style.width = '100%';

                setTimeout(() => {
                    loading.classList.add('hidden');
                    showNextSlide();
                    // Use settings.duration, restart interval if duration changes
                    let slideInterval = setInterval(showNextSlide, settings.duration * 1000);
                    // Watch for duration changes
                    const durationSlider = document.getElementById('settingDuration');
                    if (durationSlider) {
                        durationSlider.addEventListener('change', () => {
                            clearInterval(slideInterval);
                            slideInterval = setInterval(showNextSlide, settings.duration * 1000);
                        });
                    }
                }, 500);
            } catch (error) {
                console.error('Error initializing:', error);
                const loadingEl = document.getElementById('loading');
                if (loadingEl) {
                    loadingEl.innerHTML = '<div class="loading-text">Error loading collection</div><div id="error-detail" style="color: rgba(255,255,255,0.4); font-size: 0.9rem;"></div>';
                    const errorDetail = document.getElementById('error-detail');
                    if (errorDetail) {
                        errorDetail.textContent = error.message;
                    }
                }
            }
        }

        async function handleStart() {
            const welcomeScreen = document.getElementById('welcomeScreen');
            const loading = document.getElementById('loading');
            const usernameInput = document.getElementById('usernameInput');
            const startButton = document.getElementById('startButton');
            const welcomeError = document.getElementById('welcomeError');

            const username = usernameInput.value.trim();
            if (!username) {
                welcomeError.textContent = 'Please enter a username';
                return;
            }

            // Save username for next visit
            localStorage.setItem('discogsUsername', username);

            // Disable button while loading
            startButton.disabled = true;
            startButton.textContent = 'Loading...';
            welcomeError.textContent = '';

            try {
                let collectionData = await fetchUserCollection(username);

                if (collectionData.length === 0) {
                    throw new Error('No records found in this collection');
                }

                // Hide welcome screen, show loading screen
                welcomeScreen.classList.add('hidden');
                loading.style.display = 'flex';

                // Process box sets if enabled
                if (settings.expandBoxSets) {
                    const loadingText = document.querySelector('.loading-text');
                    if (loadingText) loadingText.textContent = 'Processing box sets...';
                    try {
                        collectionData = await processBoxSets(collectionData);
                    } catch (boxSetError) {
                        console.error('[BoxSet] Processing failed:', boxSetError);
                        // Continue with unexpanded collection
                        if (loadingText) loadingText.textContent = 'Box set processing failed, continuing...';
                        await new Promise(r => setTimeout(r, 1500)); // Brief pause to show message
                    }
                }

                // Start the slideshow
                await startSlideshow(collectionData);

            } catch (error) {
                welcomeError.textContent = error.message;
                startButton.disabled = false;
                startButton.textContent = 'View Collection';
            }
        }

        function applySettingsToUI() {
            // Duration slider
            const durationSlider = document.getElementById('settingDuration');
            const durationValue = document.getElementById('durationValue');
            if (durationSlider) {
                durationSlider.value = settings.duration;
                durationValue.textContent = settings.duration + 's';
            }

            // Toggles
            const toggleMap = {
                settingShuffle: 'shuffle',
                settingShowArtist: 'showArtist',
                settingShowTitle: 'showTitle',
                settingShowGenre: 'showGenre',
                settingShowTracklist: 'showTracklist',
                settingTransitions: 'enableTransitions',
                settingExpandBoxSets: 'expandBoxSets'
            };

            for (const [id, key] of Object.entries(toggleMap)) {
                const el = document.getElementById(id);
                if (el) el.checked = settings[key];
            }

            // Effect checkboxes
            const effectCheckboxes = document.querySelectorAll('#effectsGrid input[data-effect]');
            effectCheckboxes.forEach(cb => {
                cb.checked = settings.enabledEffects.includes(cb.dataset.effect);
            });
        }

        function setupSettingsPanel() {
            const settingsBtn = document.getElementById('settingsBtn');
            const settingsOverlay = document.getElementById('settingsOverlay');
            const settingsClose = document.getElementById('settingsClose');

            // Open settings
            settingsBtn.addEventListener('click', () => {
                settingsOverlay.classList.add('open');
                settingsPanelOpen = true;
                settingsBtn.classList.add('visible');
            });

            // Close settings
            const closeSettings = () => {
                settingsOverlay.classList.remove('open');
                settingsPanelOpen = false;
                resetInactivityTimer();
            };

            settingsClose.addEventListener('click', closeSettings);
            settingsOverlay.addEventListener('click', (e) => {
                if (e.target === settingsOverlay) closeSettings();
            });

            // Duration slider
            const durationSlider = document.getElementById('settingDuration');
            const durationValue = document.getElementById('durationValue');
            durationSlider.addEventListener('input', () => {
                settings.duration = parseInt(durationSlider.value);
                durationValue.textContent = settings.duration + 's';
                saveSettings();
            });

            // Toggle switches
            const toggleMap = {
                settingShuffle: 'shuffle',
                settingShowArtist: 'showArtist',
                settingShowTitle: 'showTitle',
                settingShowGenre: 'showGenre',
                settingShowTracklist: 'showTracklist',
                settingTransitions: 'enableTransitions',
                settingExpandBoxSets: 'expandBoxSets'
            };

            for (const [id, key] of Object.entries(toggleMap)) {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('change', () => {
                        settings[key] = el.checked;
                        saveSettings();
                    });
                }
            }

            // Effect checkboxes
            const effectCheckboxes = document.querySelectorAll('#effectsGrid input[data-effect]');
            effectCheckboxes.forEach(cb => {
                cb.addEventListener('change', () => {
                    const effect = cb.dataset.effect;
                    if (cb.checked) {
                        if (!settings.enabledEffects.includes(effect)) {
                            settings.enabledEffects.push(effect);
                        }
                    } else {
                        settings.enabledEffects = settings.enabledEffects.filter(e => e !== effect);
                    }
                    effectsQueue = []; // Reset queue when effects change
                    saveSettings();
                });
            });

            // Box Set Manager
            const boxSetManagerBtn = document.getElementById('boxSetManagerBtn');
            const boxSetModal = document.getElementById('boxSetModal');
            const boxSetClose = document.getElementById('boxSetClose');

            if (boxSetManagerBtn && boxSetModal) {
                boxSetManagerBtn.addEventListener('click', () => {
                    boxSetModal.classList.add('open');
                    updateBoxSetManagerUI();
                });

                boxSetClose.addEventListener('click', () => {
                    boxSetModal.classList.remove('open');
                });

                boxSetModal.addEventListener('click', (e) => {
                    if (e.target === boxSetModal) {
                        boxSetModal.classList.remove('open');
                    }
                });
            }
        }

        function init() {
            const welcomeScreen = document.getElementById('welcomeScreen');
            const loading = document.getElementById('loading');
            const usernameInput = document.getElementById('usernameInput');
            const startButton = document.getElementById('startButton');

            // Load and apply settings
            loadSettings();
            applySettingsToUI();
            setupSettingsPanel();
            setupInactivityListeners();

            // Hide loading screen initially
            loading.style.display = 'none';

            // Load saved username
            const savedUsername = localStorage.getItem('discogsUsername');
            if (savedUsername) {
                usernameInput.value = savedUsername;
            }

            // Handle start button click
            startButton.addEventListener('click', handleStart);

            // Handle Enter key in input
            usernameInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    handleStart();
                }
            });
        }

        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
